// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: slitherio.proto

#ifndef PROTOBUF_slitherio_2eproto__INCLUDED
#define PROTOBUF_slitherio_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace slitherio {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_slitherio_2eproto();
void protobuf_AssignDesc_slitherio_2eproto();
void protobuf_ShutdownFile_slitherio_2eproto();

class Circle;
class Direction;
class GameMessage;
class Snake;

enum GameMessage_MessageType {
  GameMessage_MessageType_DIR = 0,
  GameMessage_MessageType_NEARBY = 1,
  GameMessage_MessageType_DEATH = 2,
  GameMessage_MessageType_GameMessage_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GameMessage_MessageType_GameMessage_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GameMessage_MessageType_IsValid(int value);
const GameMessage_MessageType GameMessage_MessageType_MessageType_MIN = GameMessage_MessageType_DIR;
const GameMessage_MessageType GameMessage_MessageType_MessageType_MAX = GameMessage_MessageType_DEATH;
const int GameMessage_MessageType_MessageType_ARRAYSIZE = GameMessage_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameMessage_MessageType_descriptor();
inline const ::std::string& GameMessage_MessageType_Name(GameMessage_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameMessage_MessageType_descriptor(), value);
}
inline bool GameMessage_MessageType_Parse(
    const ::std::string& name, GameMessage_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameMessage_MessageType>(
    GameMessage_MessageType_descriptor(), name, value);
}
// ===================================================================

class Circle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:slitherio.Circle) */ {
 public:
  Circle();
  virtual ~Circle();

  Circle(const Circle& from);

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Circle& default_instance();

  void Swap(Circle* other);

  // implements Message ----------------------------------------------

  inline Circle* New() const { return New(NULL); }

  Circle* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Circle& from);
  void MergeFrom(const Circle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Circle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool food = 1;
  void clear_food();
  static const int kFoodFieldNumber = 1;
  bool food() const;
  void set_food(bool value);

  // optional double x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  double x() const;
  void set_x(double value);

  // optional double y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  double y() const;
  void set_y(double value);

  // optional double r = 4;
  void clear_r();
  static const int kRFieldNumber = 4;
  double r() const;
  void set_r(double value);

  // @@protoc_insertion_point(class_scope:slitherio.Circle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double x_;
  double y_;
  double r_;
  bool food_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_slitherio_2eproto();
  friend void protobuf_AssignDesc_slitherio_2eproto();
  friend void protobuf_ShutdownFile_slitherio_2eproto();

  void InitAsDefaultInstance();
  static Circle* default_instance_;
};
// -------------------------------------------------------------------

class Direction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:slitherio.Direction) */ {
 public:
  Direction();
  virtual ~Direction();

  Direction(const Direction& from);

  inline Direction& operator=(const Direction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Direction& default_instance();

  void Swap(Direction* other);

  // implements Message ----------------------------------------------

  inline Direction* New() const { return New(NULL); }

  Direction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Direction& from);
  void MergeFrom(const Direction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Direction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:slitherio.Direction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float x_;
  float y_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_slitherio_2eproto();
  friend void protobuf_AssignDesc_slitherio_2eproto();
  friend void protobuf_ShutdownFile_slitherio_2eproto();

  void InitAsDefaultInstance();
  static Direction* default_instance_;
};
// -------------------------------------------------------------------

class Snake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:slitherio.Snake) */ {
 public:
  Snake();
  virtual ~Snake();

  Snake(const Snake& from);

  inline Snake& operator=(const Snake& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Snake& default_instance();

  void Swap(Snake* other);

  // implements Message ----------------------------------------------

  inline Snake* New() const { return New(NULL); }

  Snake* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Snake& from);
  void MergeFrom(const Snake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Snake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // repeated .slitherio.Circle segments = 3;
  int segments_size() const;
  void clear_segments();
  static const int kSegmentsFieldNumber = 3;
  const ::slitherio::Circle& segments(int index) const;
  ::slitherio::Circle* mutable_segments(int index);
  ::slitherio::Circle* add_segments();
  ::google::protobuf::RepeatedPtrField< ::slitherio::Circle >*
      mutable_segments();
  const ::google::protobuf::RepeatedPtrField< ::slitherio::Circle >&
      segments() const;

  // optional .slitherio.Direction dir = 4;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 4;
  const ::slitherio::Direction& dir() const;
  ::slitherio::Direction* mutable_dir();
  ::slitherio::Direction* release_dir();
  void set_allocated_dir(::slitherio::Direction* dir);

  // @@protoc_insertion_point(class_scope:slitherio.Snake)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::RepeatedPtrField< ::slitherio::Circle > segments_;
  ::slitherio::Direction* dir_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_slitherio_2eproto();
  friend void protobuf_AssignDesc_slitherio_2eproto();
  friend void protobuf_ShutdownFile_slitherio_2eproto();

  void InitAsDefaultInstance();
  static Snake* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:slitherio.GameMessage) */ {
 public:
  GameMessage();
  virtual ~GameMessage();

  GameMessage(const GameMessage& from);

  inline GameMessage& operator=(const GameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage& default_instance();

  void Swap(GameMessage* other);

  // implements Message ----------------------------------------------

  inline GameMessage* New() const { return New(NULL); }

  GameMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage& from);
  void MergeFrom(const GameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameMessage_MessageType MessageType;
  static const MessageType DIR =
    GameMessage_MessageType_DIR;
  static const MessageType NEARBY =
    GameMessage_MessageType_NEARBY;
  static const MessageType DEATH =
    GameMessage_MessageType_DEATH;
  static inline bool MessageType_IsValid(int value) {
    return GameMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    GameMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    GameMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    GameMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return GameMessage_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return GameMessage_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return GameMessage_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .slitherio.GameMessage.MessageType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::slitherio::GameMessage_MessageType type() const;
  void set_type(::slitherio::GameMessage_MessageType value);

  // optional .slitherio.Direction dir = 2;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 2;
  const ::slitherio::Direction& dir() const;
  ::slitherio::Direction* mutable_dir();
  ::slitherio::Direction* release_dir();
  void set_allocated_dir(::slitherio::Direction* dir);

  // repeated .slitherio.Snake snakes = 3;
  int snakes_size() const;
  void clear_snakes();
  static const int kSnakesFieldNumber = 3;
  const ::slitherio::Snake& snakes(int index) const;
  ::slitherio::Snake* mutable_snakes(int index);
  ::slitherio::Snake* add_snakes();
  ::google::protobuf::RepeatedPtrField< ::slitherio::Snake >*
      mutable_snakes();
  const ::google::protobuf::RepeatedPtrField< ::slitherio::Snake >&
      snakes() const;

  // repeated .slitherio.Circle food = 4;
  int food_size() const;
  void clear_food();
  static const int kFoodFieldNumber = 4;
  const ::slitherio::Circle& food(int index) const;
  ::slitherio::Circle* mutable_food(int index);
  ::slitherio::Circle* add_food();
  ::google::protobuf::RepeatedPtrField< ::slitherio::Circle >*
      mutable_food();
  const ::google::protobuf::RepeatedPtrField< ::slitherio::Circle >&
      food() const;

  // @@protoc_insertion_point(class_scope:slitherio.GameMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::slitherio::Direction* dir_;
  ::google::protobuf::RepeatedPtrField< ::slitherio::Snake > snakes_;
  ::google::protobuf::RepeatedPtrField< ::slitherio::Circle > food_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_slitherio_2eproto();
  friend void protobuf_AssignDesc_slitherio_2eproto();
  friend void protobuf_ShutdownFile_slitherio_2eproto();

  void InitAsDefaultInstance();
  static GameMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Circle

// optional bool food = 1;
inline void Circle::clear_food() {
  food_ = false;
}
inline bool Circle::food() const {
  // @@protoc_insertion_point(field_get:slitherio.Circle.food)
  return food_;
}
inline void Circle::set_food(bool value) {
  
  food_ = value;
  // @@protoc_insertion_point(field_set:slitherio.Circle.food)
}

// optional double x = 2;
inline void Circle::clear_x() {
  x_ = 0;
}
inline double Circle::x() const {
  // @@protoc_insertion_point(field_get:slitherio.Circle.x)
  return x_;
}
inline void Circle::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:slitherio.Circle.x)
}

// optional double y = 3;
inline void Circle::clear_y() {
  y_ = 0;
}
inline double Circle::y() const {
  // @@protoc_insertion_point(field_get:slitherio.Circle.y)
  return y_;
}
inline void Circle::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:slitherio.Circle.y)
}

// optional double r = 4;
inline void Circle::clear_r() {
  r_ = 0;
}
inline double Circle::r() const {
  // @@protoc_insertion_point(field_get:slitherio.Circle.r)
  return r_;
}
inline void Circle::set_r(double value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:slitherio.Circle.r)
}

// -------------------------------------------------------------------

// Direction

// optional float x = 1;
inline void Direction::clear_x() {
  x_ = 0;
}
inline float Direction::x() const {
  // @@protoc_insertion_point(field_get:slitherio.Direction.x)
  return x_;
}
inline void Direction::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:slitherio.Direction.x)
}

// optional float y = 2;
inline void Direction::clear_y() {
  y_ = 0;
}
inline float Direction::y() const {
  // @@protoc_insertion_point(field_get:slitherio.Direction.y)
  return y_;
}
inline void Direction::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:slitherio.Direction.y)
}

// -------------------------------------------------------------------

// Snake

// optional int32 id = 1;
inline void Snake::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Snake::id() const {
  // @@protoc_insertion_point(field_get:slitherio.Snake.id)
  return id_;
}
inline void Snake::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:slitherio.Snake.id)
}

// optional int32 size = 2;
inline void Snake::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 Snake::size() const {
  // @@protoc_insertion_point(field_get:slitherio.Snake.size)
  return size_;
}
inline void Snake::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:slitherio.Snake.size)
}

// repeated .slitherio.Circle segments = 3;
inline int Snake::segments_size() const {
  return segments_.size();
}
inline void Snake::clear_segments() {
  segments_.Clear();
}
inline const ::slitherio::Circle& Snake::segments(int index) const {
  // @@protoc_insertion_point(field_get:slitherio.Snake.segments)
  return segments_.Get(index);
}
inline ::slitherio::Circle* Snake::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:slitherio.Snake.segments)
  return segments_.Mutable(index);
}
inline ::slitherio::Circle* Snake::add_segments() {
  // @@protoc_insertion_point(field_add:slitherio.Snake.segments)
  return segments_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::slitherio::Circle >*
Snake::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:slitherio.Snake.segments)
  return &segments_;
}
inline const ::google::protobuf::RepeatedPtrField< ::slitherio::Circle >&
Snake::segments() const {
  // @@protoc_insertion_point(field_list:slitherio.Snake.segments)
  return segments_;
}

// optional .slitherio.Direction dir = 4;
inline bool Snake::has_dir() const {
  return !_is_default_instance_ && dir_ != NULL;
}
inline void Snake::clear_dir() {
  if (GetArenaNoVirtual() == NULL && dir_ != NULL) delete dir_;
  dir_ = NULL;
}
inline const ::slitherio::Direction& Snake::dir() const {
  // @@protoc_insertion_point(field_get:slitherio.Snake.dir)
  return dir_ != NULL ? *dir_ : *default_instance_->dir_;
}
inline ::slitherio::Direction* Snake::mutable_dir() {
  
  if (dir_ == NULL) {
    dir_ = new ::slitherio::Direction;
  }
  // @@protoc_insertion_point(field_mutable:slitherio.Snake.dir)
  return dir_;
}
inline ::slitherio::Direction* Snake::release_dir() {
  // @@protoc_insertion_point(field_release:slitherio.Snake.dir)
  
  ::slitherio::Direction* temp = dir_;
  dir_ = NULL;
  return temp;
}
inline void Snake::set_allocated_dir(::slitherio::Direction* dir) {
  delete dir_;
  dir_ = dir;
  if (dir) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:slitherio.Snake.dir)
}

// -------------------------------------------------------------------

// GameMessage

// optional .slitherio.GameMessage.MessageType type = 1;
inline void GameMessage::clear_type() {
  type_ = 0;
}
inline ::slitherio::GameMessage_MessageType GameMessage::type() const {
  // @@protoc_insertion_point(field_get:slitherio.GameMessage.type)
  return static_cast< ::slitherio::GameMessage_MessageType >(type_);
}
inline void GameMessage::set_type(::slitherio::GameMessage_MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:slitherio.GameMessage.type)
}

// optional .slitherio.Direction dir = 2;
inline bool GameMessage::has_dir() const {
  return !_is_default_instance_ && dir_ != NULL;
}
inline void GameMessage::clear_dir() {
  if (GetArenaNoVirtual() == NULL && dir_ != NULL) delete dir_;
  dir_ = NULL;
}
inline const ::slitherio::Direction& GameMessage::dir() const {
  // @@protoc_insertion_point(field_get:slitherio.GameMessage.dir)
  return dir_ != NULL ? *dir_ : *default_instance_->dir_;
}
inline ::slitherio::Direction* GameMessage::mutable_dir() {
  
  if (dir_ == NULL) {
    dir_ = new ::slitherio::Direction;
  }
  // @@protoc_insertion_point(field_mutable:slitherio.GameMessage.dir)
  return dir_;
}
inline ::slitherio::Direction* GameMessage::release_dir() {
  // @@protoc_insertion_point(field_release:slitherio.GameMessage.dir)
  
  ::slitherio::Direction* temp = dir_;
  dir_ = NULL;
  return temp;
}
inline void GameMessage::set_allocated_dir(::slitherio::Direction* dir) {
  delete dir_;
  dir_ = dir;
  if (dir) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:slitherio.GameMessage.dir)
}

// repeated .slitherio.Snake snakes = 3;
inline int GameMessage::snakes_size() const {
  return snakes_.size();
}
inline void GameMessage::clear_snakes() {
  snakes_.Clear();
}
inline const ::slitherio::Snake& GameMessage::snakes(int index) const {
  // @@protoc_insertion_point(field_get:slitherio.GameMessage.snakes)
  return snakes_.Get(index);
}
inline ::slitherio::Snake* GameMessage::mutable_snakes(int index) {
  // @@protoc_insertion_point(field_mutable:slitherio.GameMessage.snakes)
  return snakes_.Mutable(index);
}
inline ::slitherio::Snake* GameMessage::add_snakes() {
  // @@protoc_insertion_point(field_add:slitherio.GameMessage.snakes)
  return snakes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::slitherio::Snake >*
GameMessage::mutable_snakes() {
  // @@protoc_insertion_point(field_mutable_list:slitherio.GameMessage.snakes)
  return &snakes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::slitherio::Snake >&
GameMessage::snakes() const {
  // @@protoc_insertion_point(field_list:slitherio.GameMessage.snakes)
  return snakes_;
}

// repeated .slitherio.Circle food = 4;
inline int GameMessage::food_size() const {
  return food_.size();
}
inline void GameMessage::clear_food() {
  food_.Clear();
}
inline const ::slitherio::Circle& GameMessage::food(int index) const {
  // @@protoc_insertion_point(field_get:slitherio.GameMessage.food)
  return food_.Get(index);
}
inline ::slitherio::Circle* GameMessage::mutable_food(int index) {
  // @@protoc_insertion_point(field_mutable:slitherio.GameMessage.food)
  return food_.Mutable(index);
}
inline ::slitherio::Circle* GameMessage::add_food() {
  // @@protoc_insertion_point(field_add:slitherio.GameMessage.food)
  return food_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::slitherio::Circle >*
GameMessage::mutable_food() {
  // @@protoc_insertion_point(field_mutable_list:slitherio.GameMessage.food)
  return &food_;
}
inline const ::google::protobuf::RepeatedPtrField< ::slitherio::Circle >&
GameMessage::food() const {
  // @@protoc_insertion_point(field_list:slitherio.GameMessage.food)
  return food_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace slitherio

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::slitherio::GameMessage_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::slitherio::GameMessage_MessageType>() {
  return ::slitherio::GameMessage_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_slitherio_2eproto__INCLUDED
